package model.expression;

import exception.InvalidTypeException;
import exception.UnknownOperatorException;
import model.state.IHeap;
import model.state.MyIDictionary;
import model.type.Type;
import model.value.BoolValue;
import model.value.IntValue;
import model.value.Value;

public record RelationalExp(Expression left, Expression right, String operator) implements Expression {
    @Override
    public Value evaluate(MyIDictionary<String, Value> symbolTable, IHeap<Value> heap) {
        Value leftValue = left.evaluate(symbolTable, heap);
        if (!(leftValue instanceof IntValue(int leftInt)))
            throw new InvalidTypeException("Invalid type operators");

        Value rightValue = right.evaluate(symbolTable, heap);
        if (!(rightValue instanceof IntValue(int rightInt)))
            throw new InvalidTypeException("Invalid type operators");

        boolean result= switch (operator){
            case "==" -> leftInt == rightInt;
            case "!=" -> leftInt != rightInt;
            case ">" -> leftInt > rightInt;
            case "<" -> leftInt < rightInt;
            case ">=" -> leftInt >= rightInt;
            case "<=" -> leftInt <= rightInt;
            default -> throw new UnknownOperatorException("Invalid operator");
        };

        return new BoolValue(result);
    }

    @Override
    public Expression deepCopy() {
        return new RelationalExp(left.deepCopy(), right.deepCopy(), operator);
    }

    @Override
    public Type typecheck(MyIDictionary<String, Type> typeEnv) {
        Type type1 = left.typecheck(typeEnv);
        Type type2 = right.typecheck(typeEnv);
        if (type1.equals(type2) && type1.equals(new model.type.IntType())) {
            return new model.type.BooleanType();
        } else {
            throw new InvalidTypeException("Relational expression: operands must be integers");
        }
    }
}
